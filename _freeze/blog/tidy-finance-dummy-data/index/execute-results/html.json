{
  "hash": "e26a58f8e0e8ca61f05aa3cf405df77c",
  "result": {
    "markdown": "---\ntitle: \"Dummy Data for Tidy Finance Readers without Access to WRDS\"\nauthor:\n  - name: Christoph Scheuch\n    url: https://christophscheuch.github.io/\n    affiliations:\n      - name: wikifolio Financial Technologies AG\ndate: \"2023-09-19\"\ndescription: R code to generate dummy data that can be used to run the code chunks in Tidy Finance with R or Python\nimage: thumbnail.png\nimage-alt: An image of a stylized company building on a screen in the middle of a room. The room has a futuristic setting, with a backdrop of a digital, grid-like landscape symbolizing the internet. The color palette should be a combination of cool blues and warm yellow. Created with DALL-E 2.\ncategories: \n  - Data\n---\n\n\nSince we published our book [Tidy Finance with R](../../r/index.qmd), we have received feedback from readers who don't have access to WRDS and hence cannot run the code we provide. To alleviate their constraints, we decided to create a dummy database that contains all tables and corresponding columns such that all code chunks in our book can be executed with this dummy database. We deliberately use the *dummy* label because the data is not meaningful in the sense that it allows readers to replicate the results of the book. For legal reasons, the data is also *not* a sample of the original data. We merely generate random numbers for all columns of the dummy tables. \n\nTo generate the dummy database, we use the following packages:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n── Attaching core tidyverse packages ───────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.2     ✔ readr     2.1.4\n✔ forcats   1.0.0     ✔ stringr   1.5.0\n✔ lubridate 1.9.2     ✔ tibble    3.2.1\n✔ purrr     1.0.1     ✔ tidyr     1.3.0\n── Conflicts ─────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n:::\n\n```{.r .cell-code}\nlibrary(RSQLite)\n```\n:::\n\n\nWe use the original database as an input and initialize a dummy version to store the output tables. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ntidy_finance <- dbConnect(\n  SQLite(),\n  \"../../data/tidy_finance.sqlite\",\n  extended_types = TRUE\n)\n\ntidy_finance_dummy <- dbConnect(\n  SQLite(),\n  \"../../data/tidy_finance_dummy.sqlite\",\n  extended_types = TRUE\n)\n```\n:::\n\n\nSince we draw random numbers for most of the columns, we also define a seed to ensure that the generated numbers are replicable. We also initialize vectors of dates of different frequencies over 10 years that we later use to create yearly, monthly, and daily data, respectively. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1234)\n\nstart_date <- as.Date(\"2003-01-01\")\nend_date <- as.Date(\"2022-12-31\")\n\ntime_series_years <- seq(year(start_date), year(end_date), 1)\ntime_series_months <- seq(start_date, end_date, \"1 month\")\ntime_series_days <- seq(start_date, end_date, \"1 day\")\n```\n:::\n\n\n## Create macro dummy data\n\nWe start by creating dummy data for the macroeconomic tables. The following code does this by replacing the original data with random numbers while preserving the time structure (either daily or monthly) and column names. We iterate over each table name in the `macro_tables` vector. For each table, the data is fetched from the database and stored in the `data_original` table. The code checks the column names of `data_original` to determine if the data is structured by months or by days. Depending on the structure, it sets the appropriate time series and date column name. For each relevant column (i.e., excluding colums of type date), the code generates a command to replace its values with random numbers drawn from a uniform distribution between 0 and 1. We then use the `!!!` operator to unlist and execute the list of commands. This trick actually helps us to avoid typing the same function for each column individually. Finally, the table with the dummy data is written to the new database with dummy data.\n\nNote that we do not put any meaningful structure on the macro tables because they can be freely downloaded from the original sources - check out [Accessing and Managing Financial Data](../../r/accessing-and-managing-financial-data.qmd) to get the actual data.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmacro_tables <- c(\n  \"cpi_monthly\", \"factors_ff3_daily\", \n  \"factors_ff3_monthly\", \"factors_ff5_monthly\", \n  \"factors_q_monthly\", \"industries_ff_monthly\", \n  \"macro_predictors\"\n)\n\nfor (table_name in macro_tables) {\n  data_original <- tbl(tidy_finance, table_name) |>\n    collect() |> \n    drop_na()\n  \n  if (\"month\" %in% names(data_original)) {\n    time_series <- time_series_months\n    date_column <- \"month\"\n  } else if (\"date\" %in% names(data_original)) {\n    time_series <- time_series_days\n    date_column <- \"date\"\n  }\n  \n  relevant_columns <- data_original |> \n    select(-contains(c(\"month\", \"date\"))) |> \n    names()\n  \n  commands <- unlist(\n    map(\n      relevant_columns, \n      ~rlang::exprs(!!..1 := runif(n()))\n    )\n  )\n  \n  data_dummy <- tibble(\n    !!sym(date_column) := time_series\n    ) |> \n    mutate(\n      !!!commands\n    )\n  \n  dbWriteTable(tidy_finance_dummy, table_name, \n               data_dummy, overwrite = TRUE)\n}\n```\n:::\n\n\n## Create stock dummy data\n\nLet us move on the core data used throughout the book: stock and firm characteristics. We first generate a table of stock identifiers with unique `permno` and `gvkey` values, as well as associated `exchange`, `industry`, `exchcd`, and `siccd` values. The generated data is based on the characteristics of stocks in the `crsp_monthly` table of the `tidy_finance` database, ensuring that the generated stocks reflect the distribution of industries and exchanges in the original data, but the identifiers and corresponding exchanges or industries do not reflect actual firms. Similarly, the `permno`-`gvkey` combinations are not to be used for actual CRSP or Compustat data, as they are purely constructed. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nnumber_of_stocks <- 100\n\ncrsp_stocks <- tbl(tidy_finance, \"crsp_monthly\") |>\n  group_by(permno) |> \n  filter(month == max(month, na.rm = TRUE)) |> \n  ungroup() |> \n  select(permno, gvkey, industry, exchange, exchcd, siccd) |> \n  collect()\n\nindustries <- crsp_stocks |> \n  filter(industry != \"Missing\") |> \n  count(industry) |> \n  mutate(prob = n / sum(n))\n\nexchanges <- crsp_stocks |> \n  filter(exchange != \"Other\") |> \n  count(exchange) |> \n  mutate(prob = n / sum(n))\n\nstock_identifiers <- 1:number_of_stocks |> \n  map_df(\n    function(x) {\n      tibble(\n        permno = x,\n        gvkey = as.character(x + 10000),\n        exchange = sample(exchanges$exchange, 1, \n                          prob = exchanges$prob),\n        industry = sample(industries$industry, 1, \n                          prob = industries$prob)\n      ) |> \n        mutate(\n          exchcd = case_when(\n            exchange == \"NYSE\" ~ sample(c(1, 31), n()),\n            exchange == \"AMEX\" ~ sample(c(2, 32), n()),\n            exchange == \"NASDAQ\" ~ sample(c(3, 33), n())\n          ),\n          siccd = case_when(\n            industry == \"Agriculture\" ~ sample(1:999, n()),\n            industry == \"Mining\" ~ sample(1000:1499, n()),\n            industry == \"Construction\" ~ sample(1500:1799, n()),\n            industry == \"Manufacturing\" ~ sample(1800:3999, n()),\n            industry == \"Transportation\" ~ sample(4000:4899, n()),\n            industry == \"Utilities\" ~ sample(4900:4999, n()),\n            industry == \"Wholesale\" ~ sample(5000:5199, n()),\n            industry == \"Retail\" ~ sample(5200:5999, n()),\n            industry == \"Finance\" ~ sample(6000:6799, n()),\n            industry == \"Services\" ~ sample(7000:8999, n()),\n            industry == \"Public\" ~ sample(9000:9999, n())\n          )\n        )\n    }\n  )\n```\n:::\n\n\nNext, we construct three panels of stock data with varying frequencies: yearly, monthly, and daily. We begin by creating the `stock_panel_yearly` panel. To achieve this, we combine the `stock_identifiers` table with a new table containing the variable `year` from `time_series_years`. The `crossing()` function ensures that we get all possible combinations of the two tables. After combining, we select only the `gvkey` and `year` columns for our final yearly panel.\n\nNext, we construct the `stock_panel_monthly` panel. Similar to the yearly panel, we use the `crossing()` function to combine `stock_identifiers` with a new table that has the `month` variable from `time_series_months`. After merging, we select the columns `permno`, `gvkey`, `month`, `siccd`, `industry`, `exchcd`, and `exchange` to form our monthly panel.\n\nLastly, we create the `stock_panel_daily` panel. We combine `stock_identifiers` with a table containing the `date` variable from `time_series_days`. After merging, we retain only the `permno` and `date` columns for our daily panel.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstock_panel_yearly <- crossing(\n  stock_identifiers, \n  tibble(year = time_series_years)\n) |> \n  select(gvkey, year)\n\nstock_panel_monthly <- crossing(\n  stock_identifiers, \n  tibble(month = time_series_months)\n) |> \n  select(permno, gvkey, month, siccd, industry, exchcd, exchange)\n\nstock_panel_daily <- crossing(\n  stock_identifiers, \n  tibble(date = time_series_days)\n)|> \n  select(permno, date)\n```\n:::\n\n\n### Dummy `beta` table\n\nWe then proceed to simulate beta values for our `stock_panel_monthly` table. We generate simulated monthly beta values `beta_monthly` using the `rnorm()` function. For daily beta values `beta_daily`, we take the simulated monthly beta and add a small random noise to it. This noise is generated again using the `rnorm()` function, but this time we divide the random values by 100 to ensure they are small deviations from the monthly beta.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbeta_dummy <- stock_panel_monthly |> \n  mutate(\n    beta_monthly = rnorm(n()),\n    beta_daily = beta_monthly + rnorm(n()) / 100\n  )\n\ndbWriteTable(tidy_finance_dummy, \"beta\", \n             beta_dummy, overwrite = TRUE)\n```\n:::\n\n\n### Dummy `compustat` table\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntbl(tidy_finance, \"compustat\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# Source:   table<compustat> [?? x 23]\n# Database: sqlite 3.41.2 [/Users/krise/Documents/GitHub/tidy-finance/website/data/tidy_finance.sqlite]\n  gvkey  datadate      seq    ceq    at     lt txditc   txdb  itcb\n  <chr>  <date>      <dbl>  <dbl> <dbl>  <dbl>  <dbl>  <dbl> <dbl>\n1 001000 1961-12-31 NA     NA     NA    NA      0      0         0\n2 001000 1962-12-31 NA      0.552 NA    NA     NA     NA        NA\n3 001000 1963-12-31  0.553  0.553 NA     0.345  0.008  0.008     0\n4 001000 1964-12-31  0.607  0.607  1.42  0.809  0.02   0.02      0\n5 001000 1965-12-31  0.491  0.491  2.31  1.82   0      0         0\n# ℹ more rows\n# ℹ 14 more variables: pstkrv <dbl>, pstkl <dbl>, pstk <dbl>,\n#   capx <dbl>, oancf <dbl>, sale <dbl>, cogs <dbl>, xint <dbl>,\n#   xsga <dbl>, be <dbl>, op <dbl>, year <dbl>, at_lag <dbl>,\n#   inv <dbl>\n```\n:::\n\n```{.r .cell-code}\nrelevant_columns <- tbl(tidy_finance, \"compustat\") |> \n  select(-c(gvkey, datadate, year)) |> \n  names()\n\ncommands <- unlist(\n  map(\n    relevant_columns, \n    ~rlang::exprs(!!..1 := runif(n()))\n  )\n)\n\ncompustat_dummy <- stock_panel_yearly |> \n  mutate(\n    datadate = ymd(str_c(year, \"12\", \"31\")),\n    !!!commands\n  )\n\ndbWriteTable(tidy_finance_dummy, \"compustat\", \n             compustat_dummy, overwrite = TRUE)\n```\n:::\n\n\n### Dummy `crsp_monthly` table\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntbl(tidy_finance, \"crsp_monthly\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# Source:   table<crsp_monthly> [?? x 14]\n# Database: sqlite 3.41.2 [/Users/krise/Documents/GitHub/tidy-finance/website/data/tidy_finance.sqlite]\n  permno date       month           ret  shrout altprc exchcd siccd\n   <dbl> <date>     <date>        <dbl>   <dbl>  <dbl>  <dbl> <dbl>\n1  10057 1969-09-30 1969-09-01 -0.0167  2038000   22.1      1  3541\n2  10057 1969-10-31 1969-10-01  0.0328  2038000   22.5      1  3541\n3  10057 1969-11-28 1969-11-01 -0.00556 2038000   22.4      1  3541\n4  10057 1969-12-31 1969-12-01  0.0279  3854000   23        1  3541\n5  10057 1970-01-30 1970-01-01 -0.0652  3854000   21.5      1  3541\n# ℹ more rows\n# ℹ 6 more variables: mktcap <dbl>, mktcap_lag <dbl>,\n#   exchange <chr>, industry <chr>, ret_excess <dbl>, gvkey <chr>\n```\n:::\n\n```{.r .cell-code}\ncrsp_monthly_dummy <- stock_panel_monthly |> \n  mutate(\n    date = ceiling_date(month, \"month\") - 1,\n    ret = pmax(rnorm(n()), -1),\n    ret_excess = pmax(ret - runif(n(), 0, 0.0025), -1),\n    shrout = runif(n(), 1, 50) * 1000,\n    altprc = runif(n(), 0, 1000),\n    mktcap = shrout * altprc\n  ) |> \n  group_by(permno) |> \n  arrange(month) |> \n  mutate(mktcap_lag = lag(mktcap)) |> \n  ungroup()\n\ndbWriteTable(tidy_finance_dummy, \"crsp_monthly\", \n             crsp_monthly_dummy, overwrite = TRUE)\n```\n:::\n\n\n### Dummy `crsp_daily` table\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntbl(tidy_finance, \"crsp_daily\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# Source:   table<crsp_daily> [?? x 4]\n# Database: sqlite 3.41.2 [/Users/krise/Documents/GitHub/tidy-finance/website/data/tidy_finance.sqlite]\n  permno date       month      ret_excess\n   <dbl> <date>     <date>          <dbl>\n1  10000 1986-01-08 1986-01-01   -0.0246 \n2  10000 1986-01-09 1986-01-01   -0.00025\n3  10000 1986-01-10 1986-01-01   -0.00025\n4  10000 1986-01-13 1986-01-01    0.0498 \n5  10000 1986-01-14 1986-01-01    0.0474 \n# ℹ more rows\n```\n:::\n\n```{.r .cell-code}\ncrsp_daily_dummy <- stock_panel_daily |> \n  mutate(\n    month = floor_date(date, \"month\"),\n    ret_excess = pmax(rnorm(n()), -1)\n  )\n\ndbWriteTable(tidy_finance_dummy, \"crsp_daily\", \n             crsp_daily_dummy, overwrite = TRUE)\n\ntbl(tidy_finance_dummy, \"crsp_daily\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# Source:   table<crsp_daily> [?? x 4]\n# Database: sqlite 3.41.2 [/Users/krise/Documents/GitHub/tidy-finance/website/data/tidy_finance_dummy.sqlite]\n  permno date       month      ret_excess\n   <int> <date>     <date>          <dbl>\n1      1 2003-01-01 2003-01-01     0.0882\n2      1 2003-01-02 2003-01-01     0.444 \n3      1 2003-01-03 2003-01-01     0.573 \n4      1 2003-01-04 2003-01-01     0.745 \n5      1 2003-01-05 2003-01-01     0.464 \n# ℹ more rows\n```\n:::\n:::\n\n\n## Create bond dummy data\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnumber_of_bonds <- 100\n\n## Create mergent dummy data\nmergent <- tbl(tidy_finance, \"mergent\") |> \n  collect()\n\nmaturities <- mergent |> \n  count(days = maturity - offering_date) |> \n  mutate(probability = n / sum(n))\n\namounts <- mergent |> \n  count(offering_amt) |> \n  mutate(probability = n / sum(n))\n\nfrequencies <- mergent |> \n  count(interest_frequency) |> \n  mutate(probability = n / sum(n))\n\ncoupons <- mergent |> \n  count(coupon) |> \n  mutate(probability = n / sum(n))\n\nsic <- mergent |> \n  count(sic_code) |> \n  mutate(probability = n / sum(n))\n\nmergent_dummy <- 1:number_of_bonds |> \n  map_df(\n    function(x) {\n      tibble(\n        complete_cusip = str_to_upper(\n          str_c(\n            sample(c(letters, 0:9), 12, replace = TRUE), \n            collapse = \"\"\n          )\n        ),\n      )\n    }\n  ) |> \n  mutate(\n    maturity = sample(time_series_days, n(), replace = TRUE),\n    offering_amt = sample(\n      amounts$offering_amt, n(), \n      prob = amounts$probability, \n      replace = TRUE\n    ),\n    offering_date = maturity - sample(\n      maturities$days, n(),\n      prob = maturities$probability, \n      replace = TRUE\n    ),\n    dated_date = offering_date - sample(-10:10, n(), replace = TRUE),\n    interest_frequency = sample(\n      frequencies$interest_frequency, n(), \n      prob = frequencies$probability, \n      replace = TRUE\n    ),\n    coupon = sample(\n      coupons$coupon, n(), \n      prob = coupons$probability, \n      replace = TRUE\n    ),\n    last_interest_date = pmax(maturity, offering_date, dated_date),\n    issue_id = row_number(),\n    issuer_id = sample(1:250, n(), replace = TRUE),\n    sic_code = sample(\n      sic$sic_code, n(), \n      prob = sic$probability, \n      replace = TRUE\n    )\n  )\n  \ndbWriteTable(tidy_finance_dummy, \"mergent\", \n             mergent_dummy, overwrite = TRUE)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n## Create trace_enhanced dummy data\nstart_date <- as.Date(\"2014-01-01\")\nend_date <- as.Date(\"2016-11-30\")\n\nbonds_panel <- crossing(\n  mergent_dummy |> \n    select(cusip_id = complete_cusip),\n  tibble(\n    trd_exctn_dt = seq(start_date, end_date, \"1 day\")\n  )\n)\n\ntrace_enhanced_dummy <- bind_rows(\n  bonds_panel, bonds_panel, \n  bonds_panel, bonds_panel, \n  bonds_panel) |> \n  mutate(\n    trd_exctn_tm = str_c(\n      sample(0:24, n(), replace = TRUE), \":\", \n      sample(0:60, n(), replace = TRUE), \":\", \n      sample(0:60, n(), replace = TRUE)\n    ),\n    rptd_pr = runif(n(), 10, 200),\n    entrd_vol_qt = sample(1:20, n(), replace = TRUE) * 1000,\n    yld_pt = runif(n(), -10, 10),\n    rpt_side_cd = sample(c(\"B\", \"S\"), n(), replace = TRUE),\n    cntra_mp_id = sample(c(\"C\", \"D\"), n(), replace = TRUE)\n  )\n  \ndbWriteTable(tidy_finance_dummy, \"trace_enhanced\", \n             trace_enhanced_dummy, overwrite = TRUE)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndbSendQuery(tidy_finance_dummy, \"VACUUM;\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<SQLiteResult>\n  SQL  VACUUM;\n  ROWS Fetched: 0 [complete]\n       Changed: 0\n```\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}