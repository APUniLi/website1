{
  "hash": "87a5e9a877f06699ffc307b2670e848f",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: CIR Model Calibration using Python\nauthor:\n  - name: Yuri Antonelli\n    url: 'https://github.com/YuriAntonelli'\ndate: 04/03/2024\ndescription: Routine to calibrate the Cox-Ingersoll-Ross model\ncategories:\n  - Interest rates\n  - Python\nimage: thumbnail.jpeg\nimage-alt: 'A vibrant outdoor scene under a clear, sunny sky, where a group of workers assemble a futuristic machine. The machine, situated in the center, features a complex design with gears and levers but no visible numbers or text. A colorful line chart representing an interest rate time series floats in the air, created by the machine. The chart consists of smooth, winding lines in various colors against a clear background. The workers are dressed in casual attire, and the landscape includes green grass and a few trees, contributing to the overall cheerful ambiance. Created with DALL-E 3.'\n---\n\nThe Cox–Ingersoll–Ross (CIR)^[Cox, J. C., Ingersoll Jr, J. E., & Ross, S. A. (1985). A Theory of the Term Structure of Interest Rates. Econometrica, 53(2), 385-408. [Link.](https://www.worldscientific.com/doi/abs/10.1142/9789812701022_0005)] model stands as a cornerstone within the vast expanse of Financial Mathematics literature. Originally conceived to refine the well-known Vasicek^[Vasicek, O. (1977). An equilibrium characterization of the term structure. Journal of financial economics, 5(2), 177-188. [Link.](https://doi.org/10.1016/0304-405X(77)90016-2)] model in Interest Rate Modeling, the CIR model addressed a notable limitation of its predecessor—specifically, the propensity of Gaussian models like Vasicek's to generate negative interest rates, a feature often deemed undesirable despite the theoretical possibility of negative rates in reality.\n\nIn this concise exposition, I will delineate the process of calibrating the Cox–Ingersoll–Ross model using Python. From a theoretical point of view, I will define linear models to calibrate the CIR model and test their feasibility via Monte-Carlo simulations.\n\n### CIR Model - Overview\n\nThe CIR model aims to capture the dynamics of interest rates, offering a powerful alternative to the Vasicek model. \n\nThe Vasicek model can be mathematically defined by an Ornstein–Uhlenbeck process with an added drift term. This is a stochastic process particularly suitable for interest rate dynamics, owing to its inherent properties of **stationarity** and **mean-reversion**. These attributes align with the behavior commonly observed in interest rates.\n\nThe SDE (stochastic differential equation) for the Vasicek model is the following (where $dW_t$ denotes the Wiener process): \n$$\ndr_t=k(\\theta-r_t)dt+\\sigma dW_t\n$$\n\nMoreover, the model yields an intuitive interpretation of its parameters:\n\n- $\\theta$ is the long-run average\n\n- $k$ is the intensity with which the process returns to its long-run average\n\n- $\\sigma$ is the instantaneous volatility\n\nIn contrast, the CIR model differs by introducing a novel component into the diffusion part of the process, precisely $\\sqrt{r_t}$, as depicted below:\n$$\ndr_t=k(\\theta-r_t)dt+\\sigma\\sqrt{r_t}dW_t\n$$\n\nThis seemingly minor adjustment has profound implications, as it ensures that interest rates remain strictly positive. However, this modification also engenders notable distinctions between the two models.\n\nWithout delving into mathematical intricacies, it is imperative to recognize that while the Vasicek model adheres to a Gaussian process, the CIR model deviates from this, leading to a substantially more intricate conditional distribution. However, it is not necessary to grasp the intricacies of the distribution to develop Ordinary Least Squares (OLS) estimates, as elucidated in this article.\n\n### Model Discretization\n\nThe initial step necessitates discretization to manage the CIR model effectively and derive OLS estimates. This task is efficiently achieved through the Euler-Maruyama Scheme, a numerical method enabling the transformation of the stochastic differential equation (SDE) into a discrete-time equation. Essentially, this scheme involves approximating each differential term as a finite difference, with the accuracy of the approximation improving as the time step decreases.\n\nThis leads to the following equation:\n$$\nr_{t + \\delta t} - r_t = k(\\theta - r_t)\\delta t + \\sigma \\sqrt{r_t}N(0, \\delta t)\n$$\n\nFollowing some straightforward manipulations, it can be rewritten as:\n$$\n\\frac{{r_{t + \\delta t} - r_t}}{{\\sqrt{r_t}}} = \\frac{k\\theta \\delta t}{\\sqrt{r_t}} - k\\sqrt{r_t} \\delta t + \\sigma \\sqrt{\\delta t} N(0,1)\n$$\n\nThis can be interpreted as:\n$$\ny_i = \\beta_1 z_{1,i} + \\beta_2 z_{2,i} + \\epsilon_i\n$$\n\nWhere:\n$$\n\\begin{aligned}\n    y_i &= \\frac{r_{t+\\delta t}-r_t}{\\sqrt{r_t}} \\\\\n    \\beta_1 &= k\\theta \\\\\n    \\beta_2 &= -k \\\\\n    z_{1,i} &= \\frac{\\delta t}{\\sqrt{r_t}} \\\\\n    z_{2,i} &= \\sqrt{r_t}\\delta t \\\\\n    \\epsilon_i &= \\sigma \\sqrt{\\delta t} N(0,1)\n\\end{aligned}\n$$\n\nEstimating the parameters of interest then becomes straightforward:\n$$\n\\begin{aligned}\n\\hat{k} &= -\\hat{\\beta_2} \\\\\n\\hat{\\theta} &= \\frac{\\hat{\\beta_1}}{\\hat{k}} \\\\\n\\hat{\\sigma^2} &= \\frac{\\hat{Var(\\epsilon)}}{\\delta_t}\n\\end{aligned}\n$$\n\n### Python Implementation\nUpon reviewing the mathematical details, the next step is to translate them into Python code. I will define two functions:\n\n- `simulate_cir()`: This function simulates a path based on theoretical parameters. It is important to note that in the CIR model, the term $\\sqrt{r_t}$ requires that $r_t$ remains non-negative. However, since we are working with a discrete form of the model, simulation errors may arise due to negative rates stemming from the random component of the model. These errors need to be addressed.\nThis is facilitated by the following piece of code: `np.sqrt(max(0, r))`, which guarantees that no negative interest rate is passed under the square root.\n- `ols_cir()`: This function performs the estimates based on a given array of values.\n\n::: {#e87b5796 .cell execution_count=1}\n``` {.python .cell-code}\n# import libraries\nimport numpy as np\nfrom sklearn.linear_model import LinearRegression\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n# function to simulate paths\ndef simulate_cir(k, theta, sigma, r0, T, N):\n\n    # populate an empty array\n    dt = T / N\n    interest_rate_paths = np.zeros(N+1)\n    interest_rate_paths[0] = r0 \n    for t in range(1, N+1):\n        Z = np.random.randn()\n        r = interest_rate_paths[t-1]\n        interest_rate_paths[t] = r + k * (theta-r) * dt + sigma * np.sqrt(dt) * np.sqrt(max(0, r)) * Z    \n    return interest_rate_paths\n\n# function to estimate parameters\ndef ols_cir(data, dt):\n\n    # define variables\n    Nsteps = len(data)\n    rs = data[:Nsteps - 1]  \n    rt = data[1:Nsteps]\n    \n    # model initialization\n    model = LinearRegression()\n\n    # feature engineering to fit the theoretical model\n    y = (rt - rs) / np.sqrt(rs)\n    z1 = dt / np.sqrt(rs)\n    z2 = dt * np.sqrt(rs)\n    X = np.column_stack((z1, z2))\n\n    # fit the model\n    model = LinearRegression(fit_intercept=False)\n    model.fit(X, y)\n\n    # calculate the predicted values (y_hat), residuals and the parameters\n    y_hat = model.predict(X)\n    residuals = y - y_hat\n    beta1 = model.coef_[0]        \n    beta2 = model.coef_[1]\n\n    # get the parameter of interest for CIR\n    k0 = -beta2\n    theta0 = beta1/k0\n    sigma0 = np.std(residuals)/np.sqrt(dt)\n    \n    return k0, theta0, sigma0\n```\n:::\n\n\nThe subsequent step involves applying these functions to a specific case by fixing theoretical parameters for the CIR model.\nIn this instance, I will opt for relatively standard parameter values. However, a more formal analysis would require exploring a range of values for each parameter to evaluate the robustness of the estimators under different conditions.\n\n::: {#3f2beae1 .cell execution_count=2}\n``` {.python .cell-code}\nk_true = 5 # True mean reversion speed\ntheta_true = 0.05  # True long-run mean\nsigma_true = 0.03 # True volatility of interest rates\nr0_true = 0.3 # True initial interest rate\nT = 1  # Time horizon\nN = 100  # Number of time steps\ndt = T/N\n\n# simulated path\nnp.random.seed(123)\nseries = simulate_cir(k_true, theta_true, sigma_true, r0_true, T, N)\nestimates = ols_cir(series, dt)\n\n# print results\nprint(f\"The theoretical parameters are: k={k_true}, theta={theta_true}, sigma={sigma_true}\")\nprint(f\"The estimates are: k={round(estimates[0], 3)}, theta={round(estimates[1], 3)}, sigma={round(estimates[2], 3)}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nThe theoretical parameters are: k=5, theta=0.05, sigma=0.03\nThe estimates are: k=5.078, theta=0.051, sigma=0.034\n```\n:::\n:::\n\n\n### Monte-Carlo Results\n\nThe final step entails conducting a Monte Carlo Simulation to thoroughly scrutinize how the estimators perform. The model comprises two components: a deterministic one and a stochastic one. In the preceding step, I calibrated the model using a single vector of Gaussian samples, which generated a particular path. Now, I will repeat this process with several different vectors of Gaussian samples, generating multiple paths while maintaining the same real parameters.\n\nIf the estimators are reasonably accurate, we should observe a convergence of the Monte Carlo estimates means towards the real parameters, indicating the unbiasedness of the estimators in principle.\n\nIt is important to note that due to discretization errors, there is a possibility of generating paths with negative interest rates. To address this issue, I will adopt the approach suggested in Orlando, Mininni, and Bufalo (2020)^[Orlando, G., Mininni, R. M., and Bufalo, M. (2020). Forecasting interest rates through vasicek and cir models: A partitioning approach. Journal of Forecasting, 39(4):569–579. [Link.](https://doi.org/10.1002/for.2642)], which involves shifting all series by the 99th percentile before the calibration. This allows, in most cases, to work with a positive series of data.\nIt is crucial to highlight that if we intend to use the calibrated model for predictions, we must subsequently subtract the same quantity from the predictions. This adjustment is implemented in the code via an if statement within the while loop.\n\n::: {#cell-fig-blog-cir .cell execution_count=3}\n``` {.python .cell-code}\n# define variables\nn_scenarios = 10000\npaths = np.zeros(shape=(n_scenarios, N+1))\nOLS_estimates = np.zeros(shape=(n_scenarios,3))\n\n# perform simulations\nnp.random.seed(123)\ncount = 0\nwhile count < n_scenarios:\n    # fill the array with the simulations\n    series = simulate_cir(k_true, theta_true, sigma_true, r0_true, T, N)\n    \n    # Check if there's at least one negative number in the series\n    if np.any(series < 0):\n        # Calculate the value of the 99th percentile\n        percentile_99 = np.percentile(series, 99)\n        # Add the value of the 99th percentile to each element of the series\n        series += percentile_99\n\n    paths[count, :] = series\n    \n    # OLS estimation\n    estimates = ols_cir(series, dt)\n    OLS_estimates[count,:] = estimates\n    \n    # update counter\n    count += 1\n\n# plot of the estimates distributions\ncolours = ['blue', 'red', 'green'] \nparameters = ['k', 'Theta', 'Sigma'] \nreal_values = [k_true, theta_true, sigma_true]\n\n# Set the seaborn style\nsns.set_style(\"whitegrid\")\nfor i in range(3):  # Using range(3) for iterating over indices\n\n    # Set up the plot\n    plt.figure(figsize=(2, 1))\n    sns.histplot(OLS_estimates[:, i], bins=500, color=colours[i], alpha=0.7, kde=True)\n\n    # Plot mean as black dot line\n    mean_estimate = np.mean(OLS_estimates[:, i])\n    plt.axvline(mean_estimate, color='black', linestyle='--', label='Monte-Carlo Mean')\n\n    # Plot specified value as purple dot line\n    plt.axvline(real_values[i], color='purple', linestyle='-.', label='Theoretical Value')\n\n    plt.xlabel('Estimates', fontsize=5)\n    plt.ylabel('Frequency', fontsize=5)\n    plt.title(parameters[i], fontsize=7)\n    plt.legend(fontsize=3)\n    plt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![Results of Monte Carlo Simulation for parameter k.](index_files/figure-html/fig-blog-cir-output-1.png){#fig-blog-cir width=636 height=439 fig-pos='htb'}\n:::\n\n::: {.cell-output .cell-output-display}\n![Results of Monte Carlo Simulation for parameter Theta.](index_files/figure-html/fig-blog-cir-output-2.png){#fig-blog-cir width=661 height=439 fig-pos='htb'}\n:::\n\n::: {.cell-output .cell-output-display}\n![Results of Monte Carlo Simulation for parameter Sigma.](index_files/figure-html/fig-blog-cir-output-3.png){#fig-blog-cir width=636 height=440 fig-pos='htb'}\n:::\n:::\n\n\n### Conclusions and Real-World Application\nTo summarise, this article has covered:\n\n1. Introduction to the CIR model\n\n2. Implementation of OLS estimators for model calibration\n\n3. Evaluation of estimator performance via Monte Carlo simulations\n\nTo conclude, let's include a final snippet code to apply the routine to real-world data. I will fetch the 13-week Treasury Bill Rate using the *yfinance* package and then apply the *ols_cir* function to calibrate the model. Here are a couple of insights on the code:\n\n- Data covers all of 2023\n- Following convention, dt is set to 1/252 since there are approximately 252 trading days in a year, and interest rates are expressed in annual terms\n\n::: {#85bef436 .cell execution_count=4}\n``` {.python .cell-code}\nimport yfinance as yf\n\n# Ticker symbol for US interest rate\nticker_symbol = \"^IRX\"  # 13 Week Treasury Bill Rate\n\n# Fetch data\ninterest_rate_data = yf.download(ticker_symbol, start=\"2023-01-01\", end=\"2024-01-01\")\ninterest_rate_data = interest_rate_data['Close']/100 # divide by 100 as the data are expressed in percentage\ndt = 1/252\n\n# model calibration\nestimates = ols_cir(interest_rate_data.values, dt)\nprint(f\"The estimates are: k={round(estimates[0], 3)}, theta={round(estimates[1], 3)}, sigma={round(estimates[2], 3)}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\r[*********************100%%**********************]  1 of 1 completed\nThe estimates are: k=6.442, theta=0.052, sigma=0.03\n```\n:::\n:::\n\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}