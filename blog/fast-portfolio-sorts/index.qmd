---
title: "Fast Portfolio Sorts"
author:
  - name: Christoph Scheuch
    url: https://www.tidy-intelligence.com/
date: "2024-06-06"
description: A benchmark of R approaches for efficient portfolio sorts
categories: 
  - R
  - Portfolio Sorts
  - data.table
image: thumbnail.png
image-alt: A winner's podium with three genderless robots celebrating, each holding a trophy. The robots have a sleek, modern design with neutral features. The podium is positioned in a modern office setting with bright colors, contemporary furniture, large windows letting in natural light, and vibrant decor. The first-place robot stands in the center, elevated above the second and third place robots on either side, all expressing joy. Created by DALL-E.
---

In the world of finance and investment management, implementing standard tasks like portfolio sorts in R can be approached in various ways, including using base R, `dplyr`, or `data.table`. For researchers and data analysts, it's crucial that these implementations are both correct and efficient. Even though portfolio sorting is a relatively simple task, the need to sort portfolios in numerous ways due to the variety of sorting variables and methodological uncertainties can make computational efficiency critical. This blog post will benchmark the performance of different sorting methods in R, focusing on execution time and memory usage, to provide insights for data analysts and portfolio managers on choosing the most efficient approach.

We'll dive into the following sorting approaches:

- Use the built-in `base` functions that ship with every R installation.
- Leverage the popular `dplyr` package and workhorse of [Tidy Finance with R](../../r/index.qmd).
- Explore the powerful `data.table` package and its sorting capabilities.
- Combine the `dplyr` syntax with `data.table`'s performance through `dtplyr`.

Throughout this blog post, I'll use the following packages. Notably, `bench` is used to create benchmarking results. 

```{r}
#| message: false
#| warning: false
library(dplyr)
library(dtplyr)
library(data.table)
library(bench)
library(purrr)
library(RSQLite)
```

## Data preparation

First, I start by loading the monthly CRSP data from our database (see [WRDS, CRSP, and Compustat](../../r/wrds-crsp-and-compustat.qmd) for details). The dataset has about 3 million rows and contains monthly returns between 1960 and 2023 for about 26,000 stocks. I also make sure that the data comes as a `tibble` for `dplyr`, a `data.frame` for `base`, a `data.table` for `data.table` and a “lazy” data table for `dtplyr` because I want to avoid any conversion issues in the portfolio assignments.

```{r}
tidy_finance <- dbConnect(
  SQLite(),
  "../../data/tidy_finance_r.sqlite",
  extended_types = TRUE
)

crsp_monthly_dplyr <- tbl(tidy_finance, "crsp_monthly") |>
  select(permno, month, ret_excess, mktcap_lag) |>
  collect()

crsp_monthly_base <- as.data.frame(crsp_monthly_dplyr)

crsp_monthly_dt <- copy(as.data.table(crsp_monthly_dplyr))

crsp_monthly_dtplyr <- lazy_dt(crsp_monthly_dt)
```

Note `data.table` in R uses reference semantics, which means that modifying one `data.table` object could potentially modify another if they share the same underlying data. Therefore, `copy()` ensures that `crsp_monthly_dt` is an independent copy of the data, preventing unintentional side effects from modifications in subsequent operations and ensuring a fair comparison. 

## Defining portfolio sorts

As a common denominator across approaches, I introduce a stripped down version of `assign_portfolio()` that can also be found in the [`tidyfinance`](https://cran.r-project.org/web/packages/tidyfinance/index.html) package. 

```{r}
assign_portfolio <- function(data, sorting_variable, n_portfolios) {
  
  breakpoints <- quantile(
    data[[sorting_variable]], 
    probs = seq(0, 1, length.out = n_portfolios + 1), 
    na.rm = TRUE, names = FALSE
  )

  findInterval(
    data[[sorting_variable]], breakpoints, all.inside = TRUE
  )
}
```

The goal is to apply this function to the cross-section of stocks in each month and then compute average excess returns for each portfolio across all months.  

If we want to apply the function above to each month using only `base`, then we have to first split the `data.frame` into multiple parts and `lapply()` the function to each part. After we combined the parts again to one big data.frame, we can use `aggregate()` to compute the average excess returns. 

```{r}
sort_base <- function() {
  crsp_monthly_base$portfolio <- with(
    crsp_monthly_base, 
    ave(mktcap_lag, month, FUN = function(x) assign_portfolio(data.frame(mktcap_lag = x), "mktcap_lag", n_portfolios = 10))
  )
  
  mean_ret_excess <- with(
    crsp_monthly_base, 
    tapply(ret_excess, portfolio, function(x) mean(x, na.rm = TRUE))
  )

  data.frame(
    portfolio = names(mean_ret_excess), 
    ret = unlist(mean_ret_excess)
  )
}
sort_base()
```

This approach takes about 3 seconds per execution on my machine and is in fact more than 8-times slower than the other approaches! To create a more nuanced picture for the fast and arguably more interesting approaches, I'll drop the `base` approach going forward. 

If we want to perform the same logic using `dplyr`, we can use the following approach. Note that I use `as.data.frame()` for all approaches to ensure that the output format is the same for all approaches - a necessary requirement for a meaningful benchmark (otherwise code would not be equivalent).

```{r}
sort_dplyr <- function() {
  crsp_monthly_dplyr |> 
    mutate(
      portfolio = assign_portfolio(
        pick(everything()), "mktcap_lag", n_portfolios = 10),
      by = "month"
    ) |> 
    group_by(portfolio) |> 
    summarize(ret = mean(ret_excess, na.rm = TRUE)) |> 
    as.data.frame()
}
sort_dplyr()
```

The equivalent approach in `data.table` looks as follows. Note that I deliberately don't use any pipe or intermediate assignments as to avoid any performance overhead that these might introduce. 

```{r}
sort_dt <- function() {
  as.data.frame(crsp_monthly_dt[
    , `:=`(portfolio = assign_portfolio(.SD, "mktcap_lag", n_portfolios = 10), by = month)
    ][, .(ret = mean(ret_excess, na.rm = TRUE)), keyby = .(portfolio)])
}
sort_dt()
```

Lastly, I add the `dtplyr` implementation that also takes a `data.table` as input and internally converts `dplyr` code to `data.table` syntax. Note that the final `as.data.frame()` call is used to access the results and ensure that the result format is consistent with the other approaches. 

```{r}
sort_dtplyr <- function() {
  crsp_monthly_dtplyr |> 
    mutate(
      portfolio = assign_portfolio(
        pick(everything()), "mktcap_lag", n_portfolios = 10),
      by = "month"
    )  |> 
    group_by(portfolio) |> 
    summarize(ret = mean(ret_excess, na.rm = TRUE)) |> 
    as.data.frame()
}
sort_dtplyr()
```

Now that we have verified that all code chunks create the same average excess returns per portfolio, we can proceed to the performance evaluation. 

## Benchmarking results

The `bench` package is a great utility for benchmarking and timing expressions in R. It provides functions that allow you to measure the execution time of  expressions or code chunks. This can be useful for comparing the performance of different approaches or implementations, or for identifying potential bottlenecks in your code. The following code evaluates each approach from above a 100 times and collects the results. 

```{r}
#| warning: false
#| cache: true
iterations <- 100

results <- bench::mark(
  sort_dplyr(), sort_dt(), sort_dtplyr(), 
  iterations = iterations
)
```

The following plot shows the distributions of execution times as violin plots. You can see that `data.table` takes the lead and is followed closely by `dbplyr`, while `dtplyr` takes the third place. 

```{r}
#| warning: false
#| cache: true
library(ggplot2)

autoplot(results, type = "violin") +
  labs(y = NULL, x = "Sorting approach", 
       title = "Execution time of porfolio sorts using dplyr, data.table, and dtplyr")
```

Note that all three methods are blazingly fast, given that the task is to assign 10 portfolios across up to 26,000 stocks for 755 months. I personally don't really care for the extra few milliseconds that I'd get through `data.table` by sacrificing the `dplyr` syntax because I code mostly interactively. If your context involves time constraints and needs to be as fast as possible, then you might not only prefer `data.table`, but also think about more efficient ways to assign portfolios compared to applying the function I have given above. 
