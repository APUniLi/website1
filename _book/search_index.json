[["introduction-to-tidy-finance.html", "Tidy Finance Chapter 1 Introduction to Tidy Finance 1.1 Download and work with stock market data 1.2 Scale the analysis up: tidyverse-magic 1.3 Portfolio choice problems", " Tidy Finance Christoph Scheuch, Patrick Weiss and Stefan Voigt 2022-01-13 Chapter 1 Introduction to Tidy Finance The main aim of this chapter is to familiarize yourself with the tidyverse. We start out by downloading and visualizing stock data before we move to a simple portfolio choice problem. These examples introduce you to our approach of tidy finance. 1.1 Download and work with stock market data To download price data you can use the convenient tidyquantpackage. If you have trouble using tidyquant, check out the documentation. Start the session by loading the tidyverse and the tidyquant package as shown below. # install.packages(&quot;tidyverse&quot;) # install.packages(&quot;tidyquant&quot;) library(tidyverse) library(tidyquant) We start and download daily prices for one stock market ticker, e.g. AAPL, directly from data provider Yahoo!Finance. To download the data you can use the command tq_get. If you do not know how to use it, make sure you read the help file by calling ?tq_get. We especially recommended to take a look in the examples section in the documentation. prices &lt;- tq_get(&quot;AAPL&quot;, get = &quot;stock.prices&quot;) prices %&gt;% head() # Take a glimpse on the data ## # A tibble: 6 x 8 ## symbol date open high low close volume adjusted ## &lt;chr&gt; &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 AAPL 2012-01-03 14.6 14.7 14.6 14.7 302220800 12.6 ## 2 AAPL 2012-01-04 14.6 14.8 14.6 14.8 260022000 12.7 ## 3 AAPL 2012-01-05 14.8 14.9 14.7 14.9 271269600 12.8 ## 4 AAPL 2012-01-06 15.0 15.1 15.0 15.1 318292800 12.9 ## 5 AAPL 2012-01-09 15.2 15.3 15.0 15.1 394024400 12.9 ## 6 AAPL 2012-01-10 15.2 15.2 15.1 15.1 258196400 13.0 tq_get downloads stock market data from Yahoo!Finance if you do not specify another data source. The function returns a tibble with 8 quite self-explanatory columns: symbol, date, the market prices at the open, high, low and close, the daily volume (in number of shares) and the adjusted price in USD which factors in anything that might affect the stock price after the market closes, e.g. stock splits, repurchases and dividends. Next, we use ggplot to visualize the time series of adjusted prices. prices %&gt;% # Simple visualization of the downloaded price time series ggplot(aes(x = date, y = adjusted)) + geom_line() + labs( x = NULL, y = NULL, title = &quot;AAPL stock prices&quot;, subtitle = &quot;Prices in USD, adjusted for dividend payments and stock splits&quot; ) + theme_bw() Next, we compute daily returns defined as \\((p_t - p_{t-1}) / p_{t-1}\\) where \\(p_t\\) is the adjusted day \\(t\\) price. returns &lt;- prices %&gt;% arrange(date) %&gt;% mutate(ret = adjusted / lag(adjusted) - 1) %&gt;% select(symbol, date, ret) returns %&gt;% head() ## # A tibble: 6 x 3 ## symbol date ret ## &lt;chr&gt; &lt;date&gt; &lt;dbl&gt; ## 1 AAPL 2012-01-03 NA ## 2 AAPL 2012-01-04 0.00537 ## 3 AAPL 2012-01-05 0.0111 ## 4 AAPL 2012-01-06 0.0105 ## 5 AAPL 2012-01-09 -0.00159 ## 6 AAPL 2012-01-10 0.00358 The resulting tibble contains three columns where the last contains the daily returns. Note that the first entry naturally contains NA because there is no leading price. Note also that the computations require that the time series is ordered by date - otherwise, lag would be meaningless. For the upcoming examples we remove missing values as these would require careful treatment when computing, e.g., sample averages. In general, however, make sure you understand why NA values occur and if you can simply get rid of these observations. returns &lt;- returns %&gt;% drop_na(ret) Next, we visualize the distribution of daily returns in a histogram. Just for fun, we also add a dashed red line that indicates the 5% quantile of the daily returns to the histogram - this value is a (crude) proxy for the worst return of the stock with a probability of at least 5%. quantile_05 &lt;- quantile(returns %&gt;% pull(ret), 0.05) # Compute the 5 % quantile of the returns returns %&gt;% # create a histogram for daily returns ggplot(aes(x = ret)) + geom_histogram(bins = 100) + geom_vline(aes(xintercept = quantile_05), color = &quot;red&quot;, linetype = &quot;dashed&quot; ) + labs( x = NULL, y = NULL, title = &quot;Distribution of daily AAPL returns (in percent)&quot;, subtitle = &quot;The dotted vertical line indicates the historical 5% quantile&quot; ) + theme_bw() Here, bins = 100 determines the number of bins and hence implicitly the width of the bins. Before proceeding, make sure you understand how to use the geom geom_vline() to add a dotted red line that indicates the 5% quantile of the daily returns. A typical task before proceeding with any data is to compute summary statistics for the main variables of interest. returns %&gt;% summarise(across( ret, list( daily_mean = mean, daily_sd = sd, daily_min = min, daily_max = max ) )) %&gt;% kableExtra::kable(digits = 3) ret_daily_mean ret_daily_sd ret_daily_min ret_daily_max 0.001 0.018 -0.129 0.12 # Alternatively: compute summary statistics for each year returns %&gt;% group_by(year = year(date)) %&gt;% summarise(across( ret, list( daily_mean = mean, daily_sd = sd, daily_min = min, daily_max = max ) )) %&gt;% kableExtra::kable(digits = 3) year ret_daily_mean ret_daily_sd ret_daily_min ret_daily_max 2012 0.001 0.019 -0.064 0.089 2013 0.000 0.018 -0.124 0.051 2014 0.001 0.014 -0.080 0.082 2015 0.000 0.017 -0.061 0.057 2016 0.001 0.015 -0.066 0.065 2017 0.002 0.011 -0.039 0.061 2018 0.000 0.018 -0.066 0.070 2019 0.003 0.016 -0.100 0.068 2020 0.003 0.029 -0.129 0.120 2021 0.001 0.016 -0.042 0.054 2022 -0.001 0.017 -0.027 0.025 1.2 Scale the analysis up: tidyverse-magic As a next step, we want to take the code from before and generalize it such that all the computations are performed for an arbitrary vector of tickers or even for all stocks that represent an index. Following tidy principles, it turns out to be actually quite easy to automate the download, generate the plot of the price time series and the table of summary statistics for an arbitrary number of assets. This is where the tidyverse magic starts: tidy data and a tidy workflow make it extremely easy to generalize the computations from before to as many assets you like. The following code takes any vector of tickers, e.g., ticker &lt;- c(\"AAPL\", \"MMM\", \"BA\"), and automates the download as well as the plot of the price time series. At the end, we create the table of summary statistics for an arbitrary number of assets. Figure (ref?)(fig:prices) illustrates the time series of downloaded adjusted prices for each of the 30 constituents of the Dow Jones index. Make sure you understand every single line of code! (What is the purpose of %&gt;%? What are the arguments of aes()? Which alternative geoms could you use to visualize the time series? Hint: if you do not know the answers try to change the code to see what difference your intervention causes). ticker &lt;- tq_index(&quot;DOW&quot;) # tidyquant delivers all constituents of the Dow Jones index index_prices &lt;- tq_get(ticker, get = &quot;stock.prices&quot;, from = &quot;2000-01-01&quot; ) %&gt;% # Exactly the same code as in the first part filter(symbol != &quot;DOW&quot;) # Exclude the index itself index_prices &lt;- index_prices %&gt;% # Remove assets that did not trade since January 1st 2000 group_by(symbol) %&gt;% mutate(n = n()) %&gt;% ungroup() %&gt;% filter(n == max(n)) %&gt;% select(-n) index_prices %&gt;% ggplot(aes( x = date, y = adjusted, color = symbol )) + geom_line() + labs( x = NULL, y = NULL, color = NULL, title = &quot;DOW index stock prices&quot;, subtitle = &quot;Prices in USD, adjusted for dividend payments and stock splits&quot; ) + theme_bw() + theme(legend.position = &quot;none&quot;) Do you notice the small differences relative to the code we used before? tq_get(ticker) is able to return a tibble for several symbols as well. All we need to do to illustrate all tickers instead of only one is to include color = symbol in the ggplot aesthetics. In this way, we can generate a separate line for each ticker. The same holds for returns as well. Before computing returns as before, we use group_by(symbol) such that the mutate command is performed for each symbol individually. Exactly the same logic applies for the computation of summary statistics: group_by(symbol) is the key to aggregate the time series into ticker-specific variables of interest. all_returns &lt;- index_prices %&gt;% group_by(symbol) %&gt;% # we perform the computations per symbol mutate(ret = adjusted / lag(adjusted) - 1) %&gt;% select(symbol, date, ret) %&gt;% drop_na(ret) all_returns %&gt;% group_by(symbol) %&gt;% summarise(across( ret, list( daily_mean = mean, daily_sd = sd, daily_min = min, daily_max = max ) )) %&gt;% kableExtra::kable(digits = 3) symbol ret_daily_mean ret_daily_sd ret_daily_min ret_daily_max AMGN 0.000 0.020 -0.134 0.151 AXP 0.001 0.023 -0.176 0.219 BA 0.001 0.022 -0.238 0.243 CAT 0.001 0.020 -0.145 0.147 CSCO 0.000 0.024 -0.162 0.244 CVX 0.000 0.017 -0.221 0.227 DIS 0.001 0.019 -0.184 0.160 GS 0.001 0.023 -0.190 0.265 HD 0.001 0.019 -0.287 0.141 HON 0.001 0.020 -0.174 0.282 IBM 0.000 0.017 -0.155 0.120 INTC 0.000 0.024 -0.220 0.201 JNJ 0.000 0.012 -0.158 0.122 JPM 0.001 0.024 -0.207 0.251 KO 0.000 0.013 -0.101 0.139 MCD 0.001 0.015 -0.159 0.181 MMM 0.000 0.015 -0.129 0.126 MRK 0.000 0.017 -0.268 0.130 MSFT 0.001 0.019 -0.156 0.196 NKE 0.001 0.019 -0.198 0.155 PG 0.000 0.013 -0.302 0.120 TRV 0.001 0.018 -0.208 0.256 UNH 0.001 0.020 -0.186 0.348 VZ 0.000 0.015 -0.118 0.146 WBA 0.000 0.018 -0.150 0.166 WMT 0.000 0.015 -0.102 0.117 AAPL 0.001 0.025 -0.519 0.139 Note that you are now also equipped with all tools to download price data for each ticker listed in the SP500 index with the same number of lines of code. Just use ticker &lt;- tq_index(\"SP500\") which provides you with a tibble that contains each symbol that is (currently) part of the SP500. However, dont try this if you are not prepared to wait for a couple of minutes. Sometimes, aggregation across other variables than symbol makes sense as well. For instance, suppose you are interested in the question: are days with high aggregate trading volume followed by high aggregate trading volume days? To provide some initial analysis on this question we take the downloaded tibble with prices and compute aggregate daily trading volume for all Dow Jones constituents in USD. Recall that the column volume is denoted in the number of traded shares. We multiply the trading volume with the daily closing price to get a measure of the aggregate trading volume in USD. Scaling by 1e9 denotes daily trading volume in billion USD. volume &lt;- index_prices %&gt;% mutate(volume_usd = volume * close / 1e9) %&gt;% group_by(date) %&gt;% summarise(volume = sum(volume_usd)) volume %&gt;% # Plot the time series of aggregate trading volume ggplot(aes(x = date, y = volume)) + geom_line() + labs( x = NULL, y = NULL, title = &quot;Aggregate trading volume (billion USD)&quot; ) + theme_bw() One way to illustrate the persistence of trading volume would be to plot volume on day \\(t\\) against volume on day \\(t-1\\) as in the example below: volume %&gt;% ggplot(aes(x = lag(volume), y = volume)) + geom_point() + geom_abline(aes(intercept = 0, slope = 1), linetype = &quot;dotted&quot;) + labs( x = &quot;Previous day aggregate trading volume (billion USD)&quot;, y = &quot;Aggregate trading volume (billion USD)&quot;, title = &quot;Persistence of trading volume&quot; ) + theme_bw() + theme(legend.position = &quot;None&quot;) ## Warning: Removed 1 rows containing missing values (geom_point). Do you understand where the warning ## Warning: Removed 1 rows containing missing values (geom_point). comes from and what it means? Pure eye-balling reveals that days with high trading volume are often followed by similarly high trading volume days. 1.3 Portfolio choice problems A very typically question in Finance is how to optimally allocate wealth across different assets. The standard framework for optimal portfolio selection is based on investors that dislike portfolio return volatility and like higher expected returns: the mean-variance investor. An essential tool to evaluate portfolios is the efficient frontier, the set of portfolios which satisfy the condition that no other portfolio exists with a higher expected return but with the same standard deviation of return (i.e., the risk). Let us compute and visualize the efficient frontier for a number of stocks. First, we use our dataset to compute the monthly returns for each asset. returns &lt;- index_prices %&gt;% mutate(month = floor_date(date, &quot;month&quot;)) %&gt;% group_by(symbol, month) %&gt;% summarise(price = last(adjusted), .groups = &quot;drop_last&quot;) %&gt;% mutate(ret = price / lag(price) - 1) %&gt;% drop_na(ret) %&gt;% select(-price) Next, we transform the returns from a tidy tibble into a \\((T \\times N)\\) matrix with one column for each ticker to compute the covariance matrix \\(\\Sigma\\) and also the expected return vector \\(\\mu\\). We compute the vector of sample average returns and the sample variance covariance matrix. returns_matrix &lt;- returns %&gt;% pivot_wider( names_from = symbol, values_from = ret ) %&gt;% select(-month) sigma &lt;- cov(returns_matrix) mu &lt;- colMeans(returns_matrix) Then, we compute the minimum variance portfolio weight \\(\\omega_\\text{mvp}\\) as well as the expected return \\(\\omega_\\text{mvp}&#39;\\mu\\) and volatility \\(\\sqrt{\\omega_\\text{mvp}&#39;\\Sigma\\omega_\\text{mvp}}\\) of this portfolio. Recall that the minimum variance portfolio is the vector of portfolio weights that are the solution to \\[\\arg\\min w&#39;\\Sigma w \\text{ s.t. } \\sum\\limits_{i=1}^Nw_i = 1.\\] It is easy to show analytically, that \\(\\omega_\\text{mvp} = \\frac{\\Sigma^{-1}\\iota}{\\iota&#39;\\Sigma^{-1}\\iota}\\) where \\(\\iota\\) is a vector of ones. N &lt;- ncol(returns_matrix) iota &lt;- rep(1, N) wmvp &lt;- solve(sigma) %*% iota wmvp &lt;- wmvp / sum(wmvp) c(t(wmvp) %*% mu, sqrt(t(wmvp) %*% sigma %*% wmvp)) # Expected return and volatility ## [1] 0.008468467 0.031399093 Note that the monthly volatility of the minimum variance portfolio is of the same order of magnitude than the daily standard deviation of the individual components. Thus, the diversification benefits are tremendous! Next we compute the efficient portfolio weights which achieves 3 times the expected return of the minimum variance portfolio. If you wonder where the solution \\(\\omega_\\text{eff}\\) comes from: The efficient portfolio is chosen by an investor who aims to achieve minimum variance given a minimum desired expected return \\(\\bar{\\mu}\\) such that her objective function is to choose \\(\\omega_\\text{eff}\\) as the solution to \\[\\arg\\min w&#39;\\Sigma w \\text{ s.t. } w&#39;\\iota = 1 \\text{ and } \\omega&#39;\\mu \\geq \\bar{\\mu}.\\] The code below implements the analytic solution to this optimization problem, we encourage you to verify that it is correct. # Compute efficient portfolio weights for given level of expected return mu_bar &lt;- 3 * t(wmvp) %*% mu # some benchmark return: 3 times the minimum variance portfolio expected return C &lt;- as.numeric(t(iota) %*% solve(sigma) %*% iota) D &lt;- as.numeric(t(iota) %*% solve(sigma) %*% mu) E &lt;- as.numeric(t(mu) %*% solve(sigma) %*% mu) lambda_tilde &lt;- as.numeric(2 * (mu_bar - D / C) / (E - D^2 / C)) weff &lt;- wmvp + lambda_tilde / 2 * (solve(sigma) %*% mu - D / C * solve(sigma) %*% iota) The two mutual fund theorem states that as soon as we have two efficient portfolios (such as the minimum variance portfolio and the efficient portfolio for another required level of expected returns like above), we can characterize the entire efficient frontier by combining these two portfolios. This is done in the code below. Make sure to familiarize yourself with the inner workings of the for loop!. # Use the two mutual fund theorem c &lt;- seq(from = -0.4, to = 1.9, by = 0.01) # Some values for a linear combination of two efficient portfolio weights res &lt;- tibble( c = c, mu = NA, sd = NA ) for (i in seq_along(c)) { # A for loop w &lt;- (1 - c[i]) * wmvp + (c[i]) * weff # A portfolio of minimum variance and efficient portfolio res$mu[i] &lt;- 12 * 100 * t(w) %*% mu # Portfolio expected return (annualized, in percent) res$sd[i] &lt;- 12 * 10 * sqrt(t(w) %*% sigma %*% w) # Portfolio volatility (annualized, in percent) } Finally, it is simple to visualize everything within one, powerful figure using ggplot2. # Visualize the efficient frontier res %&gt;% ggplot(aes(x = sd, y = mu)) + geom_point() + # Plot all sd/mu portfolio combinations geom_point( data = res %&gt;% filter(c %in% c(0, 1)), color = &quot;red&quot;, size = 4 ) + # locate the minimum variance and efficient portfolio geom_point( data = tibble(mu = 12 * 100 * mu, sd = 12 * 10 * sqrt(diag(sigma))), aes(y = mu, x = sd), color = &quot;blue&quot;, size = 1 ) + # locate the individual assets theme_bw() + # make the plot a bit nicer labs( x = &quot;Annualized standard deviation (in percent)&quot;, y = &quot;Annualized expected return (in percent)&quot;, title = &quot;Dow Jones asset returns and efficient frontier&quot;, subtitle = &quot;Red dots indicate the location of the minimum variance and efficient tangency portfolio&quot; ) The black efficient frontier indicates the set of portfolio a mean-variance efficient investor would choose from. Compare the performance relative to the individual assets (the blue dots) - it should become clear that diversifying yields massive performance gains (at least as long as we take the parameters \\(\\Sigma\\) and \\(\\mu\\) as given). "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
